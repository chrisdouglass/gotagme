#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var meow = require("meow");
var updateNotifier = require("update-notifier");
var init_1 = require("./init");
var clean_1 = require("./clean");
var logger = console;
var cli = meow("\n\tUsage\n\t  $ gts <verb> [<file>...] [options]\n\n    Verb can be:\n      init        Adds default npm scripts to your package.json.\n      check       Checks code for formatting and lint issues.\n      fix         Fixes formatting and linting issues (if possible).\n      clean       Removes all files generated by the build.\n\n  Options\n    --help        Prints this help message.\n    -y, --yes     Assume a yes answer for every prompt.\n    -n, --no      Assume a no answer for every prompt.\n    --dry-run     Don't make any acutal changes.\n\n\tExamples\n    $ gts init -y\n    $ gts check\n    $ gts fix\n    $ gts fix src/file1.ts src/file2.ts\n    $ gts clean\n");
function usage(msg) {
    if (msg) {
        logger.error(msg);
    }
    cli.showHelp(1);
}
function run(verb, files) {
    return __awaiter(this, void 0, void 0, function () {
        var options, lint, format, _a, passLint, passFormat, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    options = {
                        dryRun: cli.flags.dryRun || false,
                        // Paths are relative to the transpiled output files.
                        gtsRootDir: path.resolve(__dirname, '../..'),
                        targetRootDir: process.cwd(),
                        yes: cli.flags.yes || cli.flags.y || false,
                        no: cli.flags.no || cli.flags.n || false,
                        logger: logger
                    };
                    if (!(verb === 'init')) return [3 /*break*/, 2];
                    return [4 /*yield*/, init_1.init(options)];
                case 1: return [2 /*return*/, _c.sent()];
                case 2:
                    lint = require('./lint').lint;
                    format = require('./format').format;
                    _a = verb;
                    switch (_a) {
                        case 'check': return [3 /*break*/, 3];
                        case 'fix': return [3 /*break*/, 6];
                        case 'clean': return [3 /*break*/, 10];
                    }
                    return [3 /*break*/, 12];
                case 3: return [4 /*yield*/, lint(options, files)];
                case 4:
                    passLint = _c.sent();
                    return [4 /*yield*/, format(options, files)];
                case 5:
                    passFormat = _c.sent();
                    return [2 /*return*/, passLint && passFormat];
                case 6: return [4 /*yield*/, lint(options, files, true)];
                case 7:
                    _b = (_c.sent());
                    if (!_b) return [3 /*break*/, 9];
                    return [4 /*yield*/, format(options, files, true)];
                case 8:
                    _b = (_c.sent());
                    _c.label = 9;
                case 9: return [2 /*return*/, (_b)];
                case 10: return [4 /*yield*/, clean_1.clean(options)];
                case 11: return [2 /*return*/, _c.sent()];
                case 12:
                    usage("Unknown verb: " + verb);
                    return [2 /*return*/, false];
            }
        });
    });
}
updateNotifier({ pkg: cli.pkg }).notify();
if (cli.input.length < 1) {
    usage();
}
run(cli.input[0], cli.input.slice(1)).then(function (success) {
    if (!success) {
        process.exit(1);
    }
});
//# sourceMappingURL=cli.js.map